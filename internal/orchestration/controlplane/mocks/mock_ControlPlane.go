// Code generated by mockery v2.53.5. DO NOT EDIT.

package mocks

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
	controlplane "github.com/zjrosen/perles/internal/orchestration/controlplane"
)

// MockControlPlane is an autogenerated mock type for the ControlPlane type
type MockControlPlane struct {
	mock.Mock
}

type MockControlPlane_Expecter struct {
	mock *mock.Mock
}

func (_m *MockControlPlane) EXPECT() *MockControlPlane_Expecter {
	return &MockControlPlane_Expecter{mock: &_m.Mock}
}

// Archive provides a mock function with given fields: ctx, id
func (_m *MockControlPlane) Archive(ctx context.Context, id controlplane.WorkflowID) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Archive")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, controlplane.WorkflowID) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockControlPlane_Archive_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Archive'
type MockControlPlane_Archive_Call struct {
	*mock.Call
}

// Archive is a helper method to define mock.On call
//   - ctx context.Context
//   - id controlplane.WorkflowID
func (_e *MockControlPlane_Expecter) Archive(ctx interface{}, id interface{}) *MockControlPlane_Archive_Call {
	return &MockControlPlane_Archive_Call{Call: _e.mock.On("Archive", ctx, id)}
}

func (_c *MockControlPlane_Archive_Call) Run(run func(ctx context.Context, id controlplane.WorkflowID)) *MockControlPlane_Archive_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(controlplane.WorkflowID))
	})
	return _c
}

func (_c *MockControlPlane_Archive_Call) Return(_a0 error) *MockControlPlane_Archive_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockControlPlane_Archive_Call) RunAndReturn(run func(context.Context, controlplane.WorkflowID) error) *MockControlPlane_Archive_Call {
	_c.Call.Return(run)
	return _c
}

// Complete provides a mock function with given fields: ctx, id
func (_m *MockControlPlane) Complete(ctx context.Context, id controlplane.WorkflowID) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Complete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, controlplane.WorkflowID) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockControlPlane_Complete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Complete'
type MockControlPlane_Complete_Call struct {
	*mock.Call
}

// Complete is a helper method to define mock.On call
//   - ctx context.Context
//   - id controlplane.WorkflowID
func (_e *MockControlPlane_Expecter) Complete(ctx interface{}, id interface{}) *MockControlPlane_Complete_Call {
	return &MockControlPlane_Complete_Call{Call: _e.mock.On("Complete", ctx, id)}
}

func (_c *MockControlPlane_Complete_Call) Run(run func(ctx context.Context, id controlplane.WorkflowID)) *MockControlPlane_Complete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(controlplane.WorkflowID))
	})
	return _c
}

func (_c *MockControlPlane_Complete_Call) Return(_a0 error) *MockControlPlane_Complete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockControlPlane_Complete_Call) RunAndReturn(run func(context.Context, controlplane.WorkflowID) error) *MockControlPlane_Complete_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function with given fields: ctx, spec
func (_m *MockControlPlane) Create(ctx context.Context, spec controlplane.WorkflowSpec) (controlplane.WorkflowID, error) {
	ret := _m.Called(ctx, spec)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 controlplane.WorkflowID
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, controlplane.WorkflowSpec) (controlplane.WorkflowID, error)); ok {
		return rf(ctx, spec)
	}
	if rf, ok := ret.Get(0).(func(context.Context, controlplane.WorkflowSpec) controlplane.WorkflowID); ok {
		r0 = rf(ctx, spec)
	} else {
		r0 = ret.Get(0).(controlplane.WorkflowID)
	}

	if rf, ok := ret.Get(1).(func(context.Context, controlplane.WorkflowSpec) error); ok {
		r1 = rf(ctx, spec)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockControlPlane_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockControlPlane_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - spec controlplane.WorkflowSpec
func (_e *MockControlPlane_Expecter) Create(ctx interface{}, spec interface{}) *MockControlPlane_Create_Call {
	return &MockControlPlane_Create_Call{Call: _e.mock.On("Create", ctx, spec)}
}

func (_c *MockControlPlane_Create_Call) Run(run func(ctx context.Context, spec controlplane.WorkflowSpec)) *MockControlPlane_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(controlplane.WorkflowSpec))
	})
	return _c
}

func (_c *MockControlPlane_Create_Call) Return(_a0 controlplane.WorkflowID, _a1 error) *MockControlPlane_Create_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockControlPlane_Create_Call) RunAndReturn(run func(context.Context, controlplane.WorkflowSpec) (controlplane.WorkflowID, error)) *MockControlPlane_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Fail provides a mock function with given fields: ctx, id
func (_m *MockControlPlane) Fail(ctx context.Context, id controlplane.WorkflowID) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Fail")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, controlplane.WorkflowID) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockControlPlane_Fail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Fail'
type MockControlPlane_Fail_Call struct {
	*mock.Call
}

// Fail is a helper method to define mock.On call
//   - ctx context.Context
//   - id controlplane.WorkflowID
func (_e *MockControlPlane_Expecter) Fail(ctx interface{}, id interface{}) *MockControlPlane_Fail_Call {
	return &MockControlPlane_Fail_Call{Call: _e.mock.On("Fail", ctx, id)}
}

func (_c *MockControlPlane_Fail_Call) Run(run func(ctx context.Context, id controlplane.WorkflowID)) *MockControlPlane_Fail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(controlplane.WorkflowID))
	})
	return _c
}

func (_c *MockControlPlane_Fail_Call) Return(_a0 error) *MockControlPlane_Fail_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockControlPlane_Fail_Call) RunAndReturn(run func(context.Context, controlplane.WorkflowID) error) *MockControlPlane_Fail_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function with given fields: ctx, id
func (_m *MockControlPlane) Get(ctx context.Context, id controlplane.WorkflowID) (*controlplane.WorkflowInstance, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *controlplane.WorkflowInstance
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, controlplane.WorkflowID) (*controlplane.WorkflowInstance, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, controlplane.WorkflowID) *controlplane.WorkflowInstance); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*controlplane.WorkflowInstance)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, controlplane.WorkflowID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockControlPlane_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockControlPlane_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - id controlplane.WorkflowID
func (_e *MockControlPlane_Expecter) Get(ctx interface{}, id interface{}) *MockControlPlane_Get_Call {
	return &MockControlPlane_Get_Call{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockControlPlane_Get_Call) Run(run func(ctx context.Context, id controlplane.WorkflowID)) *MockControlPlane_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(controlplane.WorkflowID))
	})
	return _c
}

func (_c *MockControlPlane_Get_Call) Return(_a0 *controlplane.WorkflowInstance, _a1 error) *MockControlPlane_Get_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockControlPlane_Get_Call) RunAndReturn(run func(context.Context, controlplane.WorkflowID) (*controlplane.WorkflowInstance, error)) *MockControlPlane_Get_Call {
	_c.Call.Return(run)
	return _c
}

// GetHealthStatus provides a mock function with given fields: id
func (_m *MockControlPlane) GetHealthStatus(id controlplane.WorkflowID) (controlplane.HealthStatus, bool) {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for GetHealthStatus")
	}

	var r0 controlplane.HealthStatus
	var r1 bool
	if rf, ok := ret.Get(0).(func(controlplane.WorkflowID) (controlplane.HealthStatus, bool)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func(controlplane.WorkflowID) controlplane.HealthStatus); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(controlplane.HealthStatus)
	}

	if rf, ok := ret.Get(1).(func(controlplane.WorkflowID) bool); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// MockControlPlane_GetHealthStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHealthStatus'
type MockControlPlane_GetHealthStatus_Call struct {
	*mock.Call
}

// GetHealthStatus is a helper method to define mock.On call
//   - id controlplane.WorkflowID
func (_e *MockControlPlane_Expecter) GetHealthStatus(id interface{}) *MockControlPlane_GetHealthStatus_Call {
	return &MockControlPlane_GetHealthStatus_Call{Call: _e.mock.On("GetHealthStatus", id)}
}

func (_c *MockControlPlane_GetHealthStatus_Call) Run(run func(id controlplane.WorkflowID)) *MockControlPlane_GetHealthStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(controlplane.WorkflowID))
	})
	return _c
}

func (_c *MockControlPlane_GetHealthStatus_Call) Return(_a0 controlplane.HealthStatus, _a1 bool) *MockControlPlane_GetHealthStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockControlPlane_GetHealthStatus_Call) RunAndReturn(run func(controlplane.WorkflowID) (controlplane.HealthStatus, bool)) *MockControlPlane_GetHealthStatus_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function with given fields: ctx, q
func (_m *MockControlPlane) List(ctx context.Context, q controlplane.ListQuery) ([]*controlplane.WorkflowInstance, error) {
	ret := _m.Called(ctx, q)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 []*controlplane.WorkflowInstance
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, controlplane.ListQuery) ([]*controlplane.WorkflowInstance, error)); ok {
		return rf(ctx, q)
	}
	if rf, ok := ret.Get(0).(func(context.Context, controlplane.ListQuery) []*controlplane.WorkflowInstance); ok {
		r0 = rf(ctx, q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*controlplane.WorkflowInstance)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, controlplane.ListQuery) error); ok {
		r1 = rf(ctx, q)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockControlPlane_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockControlPlane_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - q controlplane.ListQuery
func (_e *MockControlPlane_Expecter) List(ctx interface{}, q interface{}) *MockControlPlane_List_Call {
	return &MockControlPlane_List_Call{Call: _e.mock.On("List", ctx, q)}
}

func (_c *MockControlPlane_List_Call) Run(run func(ctx context.Context, q controlplane.ListQuery)) *MockControlPlane_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(controlplane.ListQuery))
	})
	return _c
}

func (_c *MockControlPlane_List_Call) Return(_a0 []*controlplane.WorkflowInstance, _a1 error) *MockControlPlane_List_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockControlPlane_List_Call) RunAndReturn(run func(context.Context, controlplane.ListQuery) ([]*controlplane.WorkflowInstance, error)) *MockControlPlane_List_Call {
	_c.Call.Return(run)
	return _c
}

// Pause provides a mock function with given fields: ctx, id
func (_m *MockControlPlane) Pause(ctx context.Context, id controlplane.WorkflowID) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Pause")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, controlplane.WorkflowID) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockControlPlane_Pause_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Pause'
type MockControlPlane_Pause_Call struct {
	*mock.Call
}

// Pause is a helper method to define mock.On call
//   - ctx context.Context
//   - id controlplane.WorkflowID
func (_e *MockControlPlane_Expecter) Pause(ctx interface{}, id interface{}) *MockControlPlane_Pause_Call {
	return &MockControlPlane_Pause_Call{Call: _e.mock.On("Pause", ctx, id)}
}

func (_c *MockControlPlane_Pause_Call) Run(run func(ctx context.Context, id controlplane.WorkflowID)) *MockControlPlane_Pause_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(controlplane.WorkflowID))
	})
	return _c
}

func (_c *MockControlPlane_Pause_Call) Return(_a0 error) *MockControlPlane_Pause_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockControlPlane_Pause_Call) RunAndReturn(run func(context.Context, controlplane.WorkflowID) error) *MockControlPlane_Pause_Call {
	_c.Call.Return(run)
	return _c
}

// Resume provides a mock function with given fields: ctx, id
func (_m *MockControlPlane) Resume(ctx context.Context, id controlplane.WorkflowID) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Resume")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, controlplane.WorkflowID) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockControlPlane_Resume_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Resume'
type MockControlPlane_Resume_Call struct {
	*mock.Call
}

// Resume is a helper method to define mock.On call
//   - ctx context.Context
//   - id controlplane.WorkflowID
func (_e *MockControlPlane_Expecter) Resume(ctx interface{}, id interface{}) *MockControlPlane_Resume_Call {
	return &MockControlPlane_Resume_Call{Call: _e.mock.On("Resume", ctx, id)}
}

func (_c *MockControlPlane_Resume_Call) Run(run func(ctx context.Context, id controlplane.WorkflowID)) *MockControlPlane_Resume_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(controlplane.WorkflowID))
	})
	return _c
}

func (_c *MockControlPlane_Resume_Call) Return(_a0 error) *MockControlPlane_Resume_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockControlPlane_Resume_Call) RunAndReturn(run func(context.Context, controlplane.WorkflowID) error) *MockControlPlane_Resume_Call {
	_c.Call.Return(run)
	return _c
}

// Shutdown provides a mock function with given fields: ctx
func (_m *MockControlPlane) Shutdown(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Shutdown")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockControlPlane_Shutdown_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Shutdown'
type MockControlPlane_Shutdown_Call struct {
	*mock.Call
}

// Shutdown is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockControlPlane_Expecter) Shutdown(ctx interface{}) *MockControlPlane_Shutdown_Call {
	return &MockControlPlane_Shutdown_Call{Call: _e.mock.On("Shutdown", ctx)}
}

func (_c *MockControlPlane_Shutdown_Call) Run(run func(ctx context.Context)) *MockControlPlane_Shutdown_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockControlPlane_Shutdown_Call) Return(_a0 error) *MockControlPlane_Shutdown_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockControlPlane_Shutdown_Call) RunAndReturn(run func(context.Context) error) *MockControlPlane_Shutdown_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function with given fields: ctx, id
func (_m *MockControlPlane) Start(ctx context.Context, id controlplane.WorkflowID) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Start")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, controlplane.WorkflowID) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockControlPlane_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type MockControlPlane_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - ctx context.Context
//   - id controlplane.WorkflowID
func (_e *MockControlPlane_Expecter) Start(ctx interface{}, id interface{}) *MockControlPlane_Start_Call {
	return &MockControlPlane_Start_Call{Call: _e.mock.On("Start", ctx, id)}
}

func (_c *MockControlPlane_Start_Call) Run(run func(ctx context.Context, id controlplane.WorkflowID)) *MockControlPlane_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(controlplane.WorkflowID))
	})
	return _c
}

func (_c *MockControlPlane_Start_Call) Return(_a0 error) *MockControlPlane_Start_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockControlPlane_Start_Call) RunAndReturn(run func(context.Context, controlplane.WorkflowID) error) *MockControlPlane_Start_Call {
	_c.Call.Return(run)
	return _c
}

// Subscribe provides a mock function with given fields: ctx
func (_m *MockControlPlane) Subscribe(ctx context.Context) (<-chan controlplane.ControlPlaneEvent, func()) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Subscribe")
	}

	var r0 <-chan controlplane.ControlPlaneEvent
	var r1 func()
	if rf, ok := ret.Get(0).(func(context.Context) (<-chan controlplane.ControlPlaneEvent, func())); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) <-chan controlplane.ControlPlaneEvent); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan controlplane.ControlPlaneEvent)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) func()); ok {
		r1 = rf(ctx)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(func())
		}
	}

	return r0, r1
}

// MockControlPlane_Subscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Subscribe'
type MockControlPlane_Subscribe_Call struct {
	*mock.Call
}

// Subscribe is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockControlPlane_Expecter) Subscribe(ctx interface{}) *MockControlPlane_Subscribe_Call {
	return &MockControlPlane_Subscribe_Call{Call: _e.mock.On("Subscribe", ctx)}
}

func (_c *MockControlPlane_Subscribe_Call) Run(run func(ctx context.Context)) *MockControlPlane_Subscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockControlPlane_Subscribe_Call) Return(_a0 <-chan controlplane.ControlPlaneEvent, _a1 func()) *MockControlPlane_Subscribe_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockControlPlane_Subscribe_Call) RunAndReturn(run func(context.Context) (<-chan controlplane.ControlPlaneEvent, func())) *MockControlPlane_Subscribe_Call {
	_c.Call.Return(run)
	return _c
}

// SubscribeFiltered provides a mock function with given fields: ctx, filter
func (_m *MockControlPlane) SubscribeFiltered(ctx context.Context, filter controlplane.EventFilter) (<-chan controlplane.ControlPlaneEvent, func()) {
	ret := _m.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for SubscribeFiltered")
	}

	var r0 <-chan controlplane.ControlPlaneEvent
	var r1 func()
	if rf, ok := ret.Get(0).(func(context.Context, controlplane.EventFilter) (<-chan controlplane.ControlPlaneEvent, func())); ok {
		return rf(ctx, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, controlplane.EventFilter) <-chan controlplane.ControlPlaneEvent); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan controlplane.ControlPlaneEvent)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, controlplane.EventFilter) func()); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(func())
		}
	}

	return r0, r1
}

// MockControlPlane_SubscribeFiltered_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscribeFiltered'
type MockControlPlane_SubscribeFiltered_Call struct {
	*mock.Call
}

// SubscribeFiltered is a helper method to define mock.On call
//   - ctx context.Context
//   - filter controlplane.EventFilter
func (_e *MockControlPlane_Expecter) SubscribeFiltered(ctx interface{}, filter interface{}) *MockControlPlane_SubscribeFiltered_Call {
	return &MockControlPlane_SubscribeFiltered_Call{Call: _e.mock.On("SubscribeFiltered", ctx, filter)}
}

func (_c *MockControlPlane_SubscribeFiltered_Call) Run(run func(ctx context.Context, filter controlplane.EventFilter)) *MockControlPlane_SubscribeFiltered_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(controlplane.EventFilter))
	})
	return _c
}

func (_c *MockControlPlane_SubscribeFiltered_Call) Return(_a0 <-chan controlplane.ControlPlaneEvent, _a1 func()) *MockControlPlane_SubscribeFiltered_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockControlPlane_SubscribeFiltered_Call) RunAndReturn(run func(context.Context, controlplane.EventFilter) (<-chan controlplane.ControlPlaneEvent, func())) *MockControlPlane_SubscribeFiltered_Call {
	_c.Call.Return(run)
	return _c
}

// SubscribeWorkflow provides a mock function with given fields: ctx, id
func (_m *MockControlPlane) SubscribeWorkflow(ctx context.Context, id controlplane.WorkflowID) (<-chan controlplane.ControlPlaneEvent, func()) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for SubscribeWorkflow")
	}

	var r0 <-chan controlplane.ControlPlaneEvent
	var r1 func()
	if rf, ok := ret.Get(0).(func(context.Context, controlplane.WorkflowID) (<-chan controlplane.ControlPlaneEvent, func())); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, controlplane.WorkflowID) <-chan controlplane.ControlPlaneEvent); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan controlplane.ControlPlaneEvent)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, controlplane.WorkflowID) func()); ok {
		r1 = rf(ctx, id)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(func())
		}
	}

	return r0, r1
}

// MockControlPlane_SubscribeWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscribeWorkflow'
type MockControlPlane_SubscribeWorkflow_Call struct {
	*mock.Call
}

// SubscribeWorkflow is a helper method to define mock.On call
//   - ctx context.Context
//   - id controlplane.WorkflowID
func (_e *MockControlPlane_Expecter) SubscribeWorkflow(ctx interface{}, id interface{}) *MockControlPlane_SubscribeWorkflow_Call {
	return &MockControlPlane_SubscribeWorkflow_Call{Call: _e.mock.On("SubscribeWorkflow", ctx, id)}
}

func (_c *MockControlPlane_SubscribeWorkflow_Call) Run(run func(ctx context.Context, id controlplane.WorkflowID)) *MockControlPlane_SubscribeWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(controlplane.WorkflowID))
	})
	return _c
}

func (_c *MockControlPlane_SubscribeWorkflow_Call) Return(_a0 <-chan controlplane.ControlPlaneEvent, _a1 func()) *MockControlPlane_SubscribeWorkflow_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockControlPlane_SubscribeWorkflow_Call) RunAndReturn(run func(context.Context, controlplane.WorkflowID) (<-chan controlplane.ControlPlaneEvent, func())) *MockControlPlane_SubscribeWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockControlPlane creates a new instance of MockControlPlane. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockControlPlane(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockControlPlane {
	mock := &MockControlPlane{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
